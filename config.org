#+TITLE: Emacs Configuration
#+AUTHOR: Xavier Capaldi
#+PROPERTY: header-args :results silent :exports code
#+TAGS: builtin(b)
#+TAGS: {machine : home work }

* Early init file
The [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][early init file]] is loaded before the package system or GUI is initialized.
We use it to disable ~package.el~ as we will use ~straight.el~ for package management.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+END_SRC

* Package management
First bootstrap straight.el.
Normally we could do this in our normal config but if we want to install the latest version of org-mode, we need to load everything before using org-babel to load the literate config.

#+BEGIN_SRC emacs-lisp :tangle init.el
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC

** Install use-package

#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'use-package)
(setq-default use-package-compute-statistics nil)
#+END_SRC

** Integration with use-package
We can tell use-package to invoke ~straight.el~ by default.

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq straight-use-package-by-default 1)
#+END_SRC

** Extensions for use-package
*** COMMENT Control system packages
It seems to not be actively maintained and has one major flaw for managing packages across the whole system.
That flaw is that you cannot specify different package names depended on the package manager begin used.
This means that if you use this to manage packages on MacOS and Linux and the package names don't match, it will not work.

#+BEGIN_SRC emacs-lisp
(use-package system-packages)
#+END_SRC

The use-package extension actually solves this issue quite nicely and extends it but only makes sense in the context of installing required applications for a package.

#+BEGIN_SRC emacs-lisp
(use-package use-package-ensure-system-package)
#+END_SRC

* General configuration

#+BEGIN_SRC emacs-lisp
(setq-default
 coding-system-for-read 'utf-8                ; Use UTF-8 by default
 coding-system-for-write 'utf-8
 cursor-in-non-selected-windows t             ; Hide the cursor in inactive windows
 help-window-select t                         ; Focus new help windows when opened
 indent-tabs-mode nil                         ; Prefer spaces over tabs
 indicate-empty-lines t                       ; Display bitmap in left fringe on empty lines
 inhibit-startup-screen t                     ; Remove default start screen
 ring-bell-function 1                         ; Use a visual bell
 select-enable-clipboard t                    ; Merge emacs and system clipboard
 tab-always-indent 'complete                  ; Use tab as a completion instead of C-M-i
 tab-width 4                                  ; Set width for tabs
 view-read-only t                             ; Always open read-only buffers in view-mode
 visible-bell t                               ; Use a visual bell
 vc-follow-symlinks t)                        ; Don't ask for confirmation following symlinked files

(global-visual-line-mode 0)            ; Don't always wrap lines instead of extending past view
(global-hl-line-mode 0)                ; Highlight current line
(display-fill-column-indicator-mode 0) ; add indicator for the fill line
(column-number-mode 1)                 ; Show the column number
(fset 'yes-or-no-p 'y-or-n-p)          ; Replace yes/no prompts with y/n
(tool-bar-mode -1)                     ; Hide the toolbar
(menu-bar-mode -1)                     ; Hide the menubar
(tooltip-mode -1)                      ; Remove mouse hover tooltips
(scroll-bar-mode -1)                   ; Hide the scrollbar
(blink-cursor-mode 0)                  ; Don't blink the cursor
(show-paren-mode 1)                    ; Show matching parens
#+END_SRC

Store backup files in one location and automatically delete old versions.

#+BEGIN_SRC emacs-lisp :tangle no
(setq backup-directory-alist `(("." . "~/.backups/"))
      backup-by-copying t
      version-control t
      delete-old-versions nil
      kept-new-versions 20
      kept-old-versions 5)

;;(setq auto-save-file-name-transforms
;;  `((".*" "/home/xavier/.autosaves/" t)))
#+END_SRC

Improve default scrolling until Emacs 29 which will come out with pixel-based smooth scrolling.

#+BEGIN_SRC emacs-lisp
(setq-default
 mouse-wheel-scroll-amount '(1 ((shift) . 1))  ; Mouse scroll one line at a time
 mouse-wheel-progressive-speed nil             ; Don't accelerate scrolling
 mouse-wheel-follow-mouse 't                   ; Scroll window under mouse
 scroll-step 1                                 ; Keyboard scroll one line at a time
 scroll-conservatively 10000
 auto-window-vscroll nil)
#+END_SRC

Change frame title to match filename and major mode
%f will show full path.
This is crucial to work well with a dmenu script or rofi.

#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '("%b [%m]"))
#+END_SRC

* Install latest version of built-in packages                          :home:
Some tools (eglot/citar) require more-recent versions of built-in packages.
Straight.el can install a more recent version but there are all sort of issues conflicting with the built-in package.
If we want this to work, we need to install the new version before the package is loaded by anything in emacs.
For org-mode in theory the first use of org-mode is using org-babel to load this literate config so unfortunately our org-mode installation will reside in init.el.
This is only required on the linux box currently which is still running emacs 27.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package org)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(if (eq system-type 'gnu/linux)
    (progn
;;      (use-package org
;;        :demand t)
      (use-package flymake)
      (use-package project)
      (use-package xref)))
#+END_SRC

* Source system specific configuration

#+BEGIN_SRC emacs-lisp :tangle init.el
(org-babel-load-file "~/.config/emacs/config.org")
;;(cond
;; ((eq system-type 'gnu/linux)
;;  (load "~/.config/emacs/linux.el"))
;; ((eq system-type 'darwin)
;;  (load "~/.emacs.d/mac.el"))
;; ((eq system-type 'windows-nt)
;;  (load "~/.emacs.d/windows.el")))
#+END_SRC

The commented method worked well and has the advantage of supporting many different files.
However, I've stopped using this in favor of simple ~cond~ of ~if~ in conjuction with ~eq~ or ~memq~ on the ~system-type~.
With more conditions I am sure I could make the configs specific to different linux computers.
Use-package has the excellent ~:if~ keyword that can conditionally source configs.
Note that straight will still source the package but it will never be loaded if the ~:if~ condition is not met.

* Abbreviations, expansions, templates
** abbrev                                                           :builtin:
Built-in mode for simple expansions.
There are many ways to define and use abbrevs but my preferred method is to define them in advance in an abbrev file which can be loaded for specific modes with ~read-abbrev-file~.

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :straight (:type built-in))
#+END_SRC

You can define your abbrev file something like this:

#+BEGIN_SRC emacs-lisp :tangle no
(when (boundp 'python-mode-abbrev-table)
  (clear-abbrev-table python-mode-abbrev-table))

(define-abbrev-table 'python-mode-abbrev-table
  '(
    ("snek" "python" nil)
    ("todo" "# TODO: " nil)
    ("hw" "hello world" nil)
    ))
#+END_SRC

First you clear the prior abbrev table settings and then define your own set of abbrevs.
If you don't want to clear the abbrevs but extend them, you can omit the ~clear-abbrev-table~.
This is helpful if you want to activate certain sets of abbrevs when you enable a minor mode.

*** COMMENT expand                                                  :builtin:
Expand is a built-in funcionality that allows abbrevs to be used as simple expansion templates.
They are significantly simpler and less powerful than skeletons but their definition is also much simpler.
For my own uses, they are largely sufficient.
They allow jumping between entry points with ~C-x a n~ and ~C-x a p~.

#+BEGIN_SRC emacs-lisp
(use-package expand
  :straight (:type built-in)
  :after abbrev
  :hook ((expand-expand expand-jump) . indent-according-to-mode))
#+END_SRC

The simplest way to use them is to define them in the same file as the abbrevs and then load them into the abbrev table:

#+BEGIN_SRC emacs-lisp :tangle no
(defconst python-expand-list
  '(("match" "match :\ncase :\n" (7 14 16))
    )
  "Expansions for python mode")

(expand-add-abbrevs python-mode-abbrev-table python-expand-list)
#+END_SRC

Note that the numbers represent the entry points.
In an ideal world, I would define a helper function that would support converting a simpler expand definition to an abbrev.
Maybe something like ~("match" "match @:\ncase @:\n@")~.

** hippie-expand                                                    :builtin:
Bind to a key and press repeatedly to cycle between expansion functions.
Should be bound to ~M-/~ by default.

#+BEGIN_SRC emacs-lisp
(use-package hippie-expand
  :straight (:type built-in)
  :commands (hippie-expand)
  :bind ([remap dabbrev-expand] . hippie-expand) ;; ~C-/~
  :custom
  (hippie-expand-try-functions-list
   '(
     try-expand-dabbrev
     try-expand-dabbrev-all-buffers
     ;; try-expand-dabbrev-from-kill
     try-complete-lisp-symbol-partially
     try-complete-lisp-symbol
     try-complete-file-name-partially
     try-complete-file-name
     ;; try-expand-all-abbrevs
     ;; try-expand-list
     ;; try-expand-line
     )))
#+END_SRC

** skeleton                                                         :builtin:
Skeleton is a built in templating tool.
It has the bare minimum of features but seems more than sufficient for my needs.
The one major missing capability is the lack of being able to jump from field to field.
I use emacs markers to add this capability.

#+BEGIN_SRC emacs-lisp
(use-package skeleton
  :straight (:type built-in)
  ;; whenever you run a new skeleton, reset the index
  :hook (skeleton-end . skeleton-make-markers)
  :bind ("C-c n" . skeleton-next-marker)
  ;;:custom (skeleton-further-elements '((abbrev-mode nil)))
  :config
  ;; make a local variable to store the index of the skeleton list
  (defvar skeleton-index 1)
  (make-local-variable 'skeleton-index)
  ;; and another variable to store markers
  (defvar skeleton-markers nil)
  (make-local-variable 'skeleton-markers)

  (defun skeleton-make-markers ()
    (setq skeleton-markers nil)
    (save-excursion ;; because we want to go back to start at the end
      (dolist
          (pos skeleton-positions)
        (goto-char pos) ;; go to first position
        (setq skeleton-markers
              (push
               (point-marker)
               skeleton-markers))));; save position as a mark
    (setq skeleton-index 1)) ;; save our starting index
  ;; this assumes the first point is also where you have the cursor begin at the end of skeleton entry

  (defun skeleton-next-marker ()
    (interactive)
    (goto-char
     (marker-position
      (nth
       (% skeleton-index
          (length skeleton-positions))
       skeleton-markers)))
    ;; update index
    (setq skeleton-index (+ skeleton-index 1)))

  ;; sample skeleton with two set positions (@)
  (define-skeleton skel-defun
    "Insert a defun template."
    "Name: "
    "(defun " str " (" @ - ")" \n
    "  (" @ _ ")" \n))
#+END_SRC

* Bookmarks                                                         :builtin:

#+BEGIN_SRC emacs-lisp
(use-package bookmark
  :straight (:type built-in))
#+END_SRC

* Browser
** COMMENT External browser                                                 :builtin:
~browse-url~ uses your default browser; firefox in my case.

#+BEGIN_SRC emacs-lisp
(use-package browse-url
  :straight (:type built-in)
  :custom
  (browse-url-handlers 'browse-url-generic))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'gnu/linux)
    (setq browse-url-generic-program "firefox")
  (setq browse-url-generic-program "open"))
#+END_SRC

** TODO eww                                                         :builtin:
* Buffers
** ibuffer                                                          :builtin:
~ibuffer~ is nicer than the ~buffer-menu~.

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :straight (:type built-in)
  :bind ("C-x C-b" . ibuffer))
#+END_SRC

* COMMENT Comint
Mac uses zsh which echoes back every input command creating a lot of blank space in shell mode.
None of the following worked to remove them.

#+BEGIN_SRC emacs-lisp
(setq explicit-shell-file-name "/bin/zsh")
(setq shell-file-name "zsh")
(setq explicit-zsh-args '("--login" "--interactive"))
(defun zsh-shell-mode-setup ()
  (setq-local comint-process-echoes t))
(add-hook 'shell-mode-hook #'zsh-shell-mode-setup)


;;(use-package comint
;;  :straight (:type built-in)
;;  :hook (comint-mode . (setq comint-process-echoes t)))
  
;;  :config
;;  (setq comint-process-echoes t)
;;  (setq explicit-zsh-args '("--interactive" "--login")))
#+END_SRC

* Completion framework
** consult
Similar to Ivy's Counsel, Consult improves many basic emacs commands.
Really should check documentation to figure out the configuration.

We can use consult as our ~completion-in-region~ function so that completions appear using our current completion system (Vertico).
This works well except for eglot (or lsp-mode).
LSP provides completions based on the input at point in the buffer.
As soon as you invoke ~completion-in-region~, you are no longer inserting into the buffer so you don't get updated completions from LSP.
One obvious example is if you are in a Go file with eglot enabled.
Typing ~fmt~ and then calling ~completion-at-point~ will only bring up a few completions but you will not (for example) see ~fmt.Printf~ as an option.
Typing ~fmt.~ and then calling ~completion-at-point~ will bring up all the possible completions.
With an in-buffer completion system like [[https://github.com/minad/corfu][corfu]] you could simply add the period and the completions would update but with consult in the minibuffer, that is not possible.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package consult
  ;; Enable automatic preview at point in the *Completions* buffer.
  ;; This is relevant when you use the default completion UI,
  ;; and not necessary for Vertico, Selectrum, etc.
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :bind (:map isearch-mode-map
              ("C-c l" . consult-line))
  :config
  (setq completion-in-region-function
      (lambda (&rest args)
        (apply (if vertico-mode
                   #'consult-completion-in-region
                 #'completion--in-region)
               args)))
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package consult
  ;; Enable automatic preview at point in the *Completions* buffer.
  ;; This is relevant when you use the default completion UI,
  ;; and not necessary for Vertico, Selectrum, etc.
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :bind (:map isearch-mode-map
              ("C-c l" . consult-line)))
#+END_SRC

*** TODO [[https://github.com/minad/affe][affe]]
** corfu

#+BEGIN_SRC emacs-lisp
(use-package corfu
  ;;:straight (:includes corfu-echo)
  ;;:load-path "straight/repos/corfu/extensions"
  ;; Optional customizations
  ;; :custom
  ;; (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  ;; (corfu-auto t)                 ;; Enable auto completion
  ;; (corfu-separator ?\s)          ;; Orderless field separator
  ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
  ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
  ;; (corfu-preview-current nil)    ;; Disable current candidate preview
  ;; (corfu-preselect 'prompt)      ;; Preselect the prompt
  ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
  ;; (corfu-scroll-margin 5)        ;; Use scroll margin

  ;; Enable Corfu only for certain modes.
  ;; :hook ((prog-mode . corfu-mode)
  ;;        (shell-mode . corfu-mode)
  ;;        (eshell-mode . corfu-mode))

  ;; Recommended: Enable Corfu globally.
  ;; This is recommended since Dabbrev can be used globally (M-/).
  ;; See also `corfu-excluded-modes'.
  :init
  (global-corfu-mode))
#+END_SRC

*** COMMENT corfu-info
#+BEGIN_SRC emacs-lisp
(use-package corfu-info
  :load-path "straight/repos/corfu/extensions/")
#+END_SRC

*** COMMENT corfu-echo
#+BEGIN_SRC emacs-lisp
(use-package corfu-echo
  :load-path "straight/repos/corfu/extensions/")
#+END_SRC

** embark
Contextual actions?
There is a lot to unpack here
[[https://karthinks.com/software/fifteen-ways-to-use-embark/][15 ways to use Embark by Karthinks]]

#+BEGIN_SRC emacs-lisp
(use-package embark
  :bind
  (("C-." . embark-act)
   ("M-." . embark-dwim))
  :custom
  (embark-prompter 'embark-completing-read-prompter))
#+END_SRC

*** Embark-Consult

#+BEGIN_SRC emacs-lisp
  (use-package embark-consult
    :after (embark consult))
#+END_SRC

** COMMENT hotfuzz
#+BEGIN_SRC emacs-lisp
(use-package hotfuzz
  :init
  (setq completion-styles '(hotfuzz)))
#+END_SRC

** kind-icon
#+BEGIN_SRC emacs-lisp
(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default) ; to compute blended backgrounds correctly
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+END_SRC

** marginalia
This adds marginalia to minibuffer or completions buffer results.

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :bind (:map minibuffer-local-map
              ("M-A" . marginalia-cycle))

  :init (marginalia-mode 1))
#+END_SRC

** orderless
This is an optional completion style which allows out of order completions.
For example: "emacs-lisp" could be matched with "lisp mac".

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :init
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC

** vertico
This puts completions directly into the minibuffer instead of a completions buffer.
An alternative built into emacs 28 is ~fido-vertical-mode~ but generally I prefer vertico.

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :init (vertico-mode 1))
#+END_SRC

* Dired                                                             :builtin:
#+BEGIN_SRC emacs-lisp
(use-package dired
  :straight (:type built-in)
;;  :init
;;  (defun xcc/dired-do-dragon (&optional arg file-list)
;;    "Open all marked files in dragon"
;;    (interactive
;;     (dired-do-async-shell-command "* dragon --and-exit --all" arg (dired-get-marked-files t current-prefix-arg nil nil t))))
  :custom
  ;; --list-directories-first
  ((dired-listing-switches "-alh"))
  :config
  (put 'dired-find-alternate-file 'disabled nil))
#+END_SRC

** TODO dired-filter
** TODO dired-open
** TODO dired-rainbow
** TODO dired-subtree
** TODO dired-ranger
** TODO dired-narrow
** TODO dired-collapse

** TODO image-dired                                                 :builtin:
* Email                                                                :home:
See [[file:~/Syncthing/org/email.org][system configuration for email]].
Email is synced using ~mbsync~ and ~msmtp~ is used to send messages.
Notmuch is my preferred email manager and client.

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'gnu/linux)
    (org-babel-load-file "~/Syncthing/org/email.org"))
#+END_SRC

* Enhanced editing
** puni
Similar to lispy but generic.

#+BEGIN_SRC emacs-lisp
(use-package puni
  :defer t)
  ;;:init
  ;; autoloads setup to defer
  ;;(puni-global-mode))
#+END_SRC

** COMMENT aggressive-indent

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent)
#+END_SRC

** hungry-delete
Deleting a whitespace character will instead delete up to the next non-whitespace character.
I enable for particular modes only since if conflicts with the paging functionality in eshell.

#+BEGIN_SRC emacs-lisp
(use-package hungry-delete
  :hook (go-mode)
  ;;:init (global-hungry-delete-mode)
  :custom
  (hungry-delete-join-reluctantly t))
#+END_SRC

** dumb-jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+END_SRC

* Helpful
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind (([remap describe-function] . helpful-callable) ;; C-h f
         ([remap describe-variable] . helpful-variable) ;; C-h v
         ([remap describe-key] . helpful-key))) ;; C-h k
#+END_SRC

* Language server protocol
** eglot
Rather than installing a million packages for each programming language, the principle of the Language Server Protocol or LSP is that a centralized server can take care of a lot of the nice features with minimal effort.
I think simplicity is a nice advantage here although of course, without internet you are basically coding on your own again.
That could be seen as a perk if you like working minimally sometimes or for some projects.
There are two methods of using LSP in emacs: ~lsp-mode~ or ~eglot~.
~lsp-mode~ is often portrayed as a batteries-included tool while ~eglot~ is minimal and only relies on built-in emacs functionality.
In reality, modern ~lsp-mode~ is becoming more modular and can be quite minimal if so desired.
One downside of ~eglot~ is that the maintainer is not an adopter of ~use-package~ or a modern emacs package manager like ~straight.el~.
There also appears to be an issue with ~flymake~ and ~eglot~.
To get ~flymake~ working properly, you need to find the occurance of ~string-replace~ and exchange it for ~replace-regexp-in-string~.
Perhaps this will be fixed in the future.
Another strength of ~lsp-mode~ is that it can integrate with ~dap-mode~.
The main strength of ~eglot~ is that it is aiming to become the integrated version of lsp in emacs.
Luckily, minimal ~lsp-mode~ and ~eglot~ are used very similarly, so probably just use whichever performs best for your system.

You will also need to install the appropriate language server for the languages you will be working with.
For Golang on Fedora I can install via dnf: ~sudo dnf install golang-x-tools-gopls~.

#+BEGIN_SRC emacs-lisp
(use-package eglot
  :after (project flymake xref)
  :commands eglot)
#+END_SRC

** consult-eglot

#+BEGIN_SRC emacs-lisp
(use-package consult-eglot
  :after (eglot consult)
  :commands consult-eglot-symbols)
#+END_SRC

* Line numbers
#+BEGIN_SRC emacs-lisp
(use-package linum
  :straight (:type built-in)
  :hook (prog-mode . linum-mode))
#+END_SRC
* Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :after hydra
  :mode "\\.md\\'"
  :bind (:map markdown-mode-map
	      ("C-c h" . markdown-hydra/body))
  :config
  (defhydra markdown-hydra (:color pink :hint none)
    "
         shift up
            _k_
promote _h_   +   _l_ demote     _RET_ do
            _j_
        shift down
"
    ("q" nil)
    ("RET" markdown-do)
;;    ("o" markdown-open)
    ("L" markdown-demote)
;;    ("ce" markdown-export)
    ("K" markdown-move-up)
    ("H" markdown-promote)
;;    ("" markdown-up-list)
;;    ("]" markdown-complete)
    ("-" markdown-insert-hr)
    ("J" markdown-move-down)
;;    ("n" markdown-next-link)
;;    ("cp" markdown-preview)
;;    ("cc" markdown-check-refs)
    ("h" backward-char)
    ("l" forward-char)
    ("j" next-line)
    ("k" previous-line)
    ))
#+END_SRC

* COMMENT Meow

#+BEGIN_SRC emacs-lisp
(use-package meow
  :init
  (defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("<escape>" . ignore)))
  :config
  (meow-setup)
  (meow-global-mode 1)
  ;; for notmuch as discussed here: https://github.com/meow-edit/meow/discussions/286
  (dolist (state '((notmuch-hello-mode . motion)
                   (notmuch-search-mode . motion)
                   (notmuch-tree-mode . motion)
                   (notmuch-show-mode . motion)))
    (add-to-list 'meow-mode-state-list state))
  :custom
  (meow-use-clipboard t))
#+END_SRC

* Notetaking and reference management                                  :home:
Previously I used a combination of ivy-bibtex, pdf-tools, org-ref, org-roam and org-roam-bibtex to handle my notes (literature-based and otherwise).
Citar, in combination with modern vertical completing-read packages, allows me simplify the whole setup.
Citar replaces the functionality of ivy-bibtex and even goes further beyond by allowing the inclusion of an org-id to each note.
This is required for org-roam to work properly and previously I needed org-roam-bibtex just to handle this functionality.
Now with citar I can remove ivy-bibtex and org-roam bibtex.
I'll still keep org-ref for now purely because it can generate nice bibtex entries from a variety of sources.
Luckily org-ref removed dependencies on helm.

** bibtex-completion
Required by org-ref.

#+BEGIN_SRC emacs-lisp
(use-package bibtex-completion
  :if (eq system-type 'gnu/linux))
#+END_SRC

** citar
This is an alternative to ivy-bibtex.

#+BEGIN_SRC emacs-lisp
(use-package citar
  :if (eq system-type 'gnu/linux)
  :after vertico ;; or some other vertical completion
  :custom
  (citar-bibliography '("/home/xavier/OneDrive/library/references.bib"))
  (citar-library-paths '("/home/xavier/OneDrive/library/"))
  (citar-notes-paths '("/home/xavier/OneDrive/notes/"))
  ;;(citar-file-note-org-include '(org-id)) ;; required for org-roam
  (citar-file-find-additional-files t)
  (citar-file-additional-files-separator "_"))
#+END_SRC

** denote
#+BEGIN_SRC emacs-lisp
(use-package denote
  :if (eq system-type 'gnu/linux)
  :hook (find-file . denote-link-buttonize-buffer)
  :custom
  (denote-file-type 'org)
  (denote-infer-keywords t)
  (denote-known-keywords '("emacs"))
  (denote-directory "/home/xavier/Syncthing/notes"))
#+END_SRC

I have two use cases or types of notes that I want to store in the same database:

*** Bibliographic notes
I want to store a single note file for each paper in my literature library.
This will allow me to read and share notes on a particular paper since they are all gathered in one spot.
However I still want to be able to link particular notes on a paper with other notes so I will make extensive use of the node linking.

*** Other topic notes
Other topics may not be split by reference.
For example a topic on object oriented programming in python might just be an aggregate of my own experience and notes and thus it isn't important to maintain the same cohesion.
That could be one large note, several smaller notes or several smaller notes that I later summarize in a large note.
Since everything is plain text, refactoring later should not be terrible.
*** evergreen notes
** org-ref
Org-ref purely for generating bibtex entries nicely.
Check out `org-ref-bibtex-hydra` as well to nicely navigate and edit a bibtex file.
Good ideas from that ...

#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :if (eq system-type 'gnu/linux)
  :custom
  ;; don't create notes by default when adding files to library
  (doi-utils-make-notes t)
  ;; since we use ivy-bibtex
  (bibtex-completion-bibliography "/home/xavier/OneDrive/library/references.bib")
  (bibtex-completion-library-path "/home/xavier/OneDrive/library")
  (bibtex-completion-notes-path "/home/xavier/OneDrive/notes")
  ;; format how we generate keys
  (bibtex-autokey-year-length 4)
  (bibtex-autokey-name-year-separator "-")
  (bibtex-autokey-year-title-separator "-")
  (bibtex-autokey-titleword-separator "-")
  (bibtex-autokey-titlewords 2)
  (bibtex-autokey-titlewords-stretch 1)
  (bibtex-autokey-titleword-length 5))
#+END_SRC

** pdf-tools

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :if (eq system-type 'gnu/linux)
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-width))
#+END_SRC

* Org                                                               :builtin:
** Simple setup                                                        :work:

#+BEGIN_SRC emacs-lisp
(use-package org
  :if (eq system-type 'darwin)
  :straight (:type built-in)
  :config
  ;; Org-babel supported languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (python . t)))
  :custom
  (org-adapt-indentation nil)
  (org-edit-src-content-indentation 0))
#+END_SRC

** Complex setup with planning methodology                             :home:
#+BEGIN_SRC emacs-lisp
(use-package org
  :if (eq system-type 'gnu/linux)
  :after ob-d2
  :bind (:map org-mode-map
              ;; These commands would normally add current org file to agenda.
              ;; Better to assign them manually with org-agenda-files
              ("C-c [" . nil)
              ("C-c ]" . nil))
  :config
  ;; Habits
  (add-to-list 'org-modules 'org-habit)

  ;; Org-babel supported languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (python . t)
     (d2 . t)))

  :custom
  ;; Don't indent text by default
  (org-adapt-indentation nil)
  (org-edit-src-content-indentation 0)

  ;; Define all project files or files that contain dates
  (org-agenda-files
   '("/home/xavier/Syncthing/org/todo.org"))

  (org-agenda-start-with-log-mode t)
  (org-deadline-warning-days 14)
  (org-log-done 'time)
  (org-log-into-drawer t)

  (org-todo-keywords
   '((sequence "TODO(t)" "|" "DONE(d!)")
     (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")))
  ;; select a todo from any in the above list quickly
  (org-use-fast-todo-selection t)

  ;; Enforce todo dependencies
  ;; Parent nodes can only be finished if all children are finished
  (org-enforce-todo-dependencies t)
  (org-enforce-todo-checkbox-dependencies t)
  ;; Tasks which have unfulfilled dependencies (children or those linked by org-edna) will remain invisible on the agenda
  (org-agenda-dim-blocked-tasks 'invisible)

  ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))

  ; Use full outline paths for refile targets
  (setq org-refile-use-outline-path t)

  ; Targets complete directly
  (setq org-outline-path-complete-in-steps nil)

  ; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes (quote confirm))

  (org-file-apps '((auto-mode . emacs)
                   (directory . emacs)
                   ("\\.mm\\'" . default)
                   ("\\.x?html?\\'" . default)
                   ("\\.pdf\\'" . default))))
#+END_SRC

** COMMENT org-edna
This package is only used for phd.org and project_A.org.
It allows defining dependencies and triggers.
Normal org mode can only specify hierarchical dependencies while org edna will allow non-linear dependencies.

#+BEGIN_SRC emacs-lisp
  (use-package org-edna
    :hook (org-mode))
#+END_SRC

* Printing                                                          :builtin:
Printing from emacs requires some configuration.
The built-in printing interface is the closest to a modern printing interface but still requires some effort to configure which I haven't done yet.
Instead a cross-platform alternative is to use the browser as a printing tool.
For files like PDF or image files we can open directly in the browser and print from there.
For text buffers we can ~htmlfontify-buffer~ and browse that buffer in the browser.
We could probably infer the printing method using [[https://emacsredux.com/blog/2020/06/14/checking-the-major-mode-in-emacs-lisp/][derived-mode-p]].

#+BEGIN_SRC emacs-lisp :noweb yes
(use-package printing
  :straight (:type built-in)
  :after hydra
  :bind ("C-c p" . printing-hydra/body)
  :config
  <<HYDRA_PRINT>>)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref HYDRA_PRINT
(defhydra printing-hydra (:color blue)
    "PRINTING HYDRA"
    ("q" nil "quit hydra" :color blue :column nil)
    ("r" browse-url-of-buffer "raw")
    ("t" (progn (htmlfontify-buffer) (browse-url-of-buffer))
     "text buffer")
    ("o" (progn (org-html-export-as-html) (browse-url-of-buffer))
     "org buffer")
    ("f" browse-url-of-file "file")
    ("p" pr-interface "printing interface"))
#+END_SRC

** TODO consider adding support to citar for pdf and embark
* Programming helpers
** asdf                                                                :work:

#+BEGIN_SRC emacs-lisp
(use-package asdf
  :if (eq system-type 'darwin)
  :straight (:host github :repo "tabfugnic/asdf.el"
                   :branch "main")
  :config
  (asdf-enable))
#+END_SRC

** COMMENT apheleia
The autoload is configured such that this isn't loading until you save a file.

#+BEGIN_SRC emacs-lisp
(use-package apheleia)
  ;;:init (apheleia-global-mode 1))
#+END_SRC

** editorconfig

#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :config
  (editorconfig-mode 1))
#+END_SRC

** TODO [[https://github.com/purcell/emacs-reformatter][emacs-reformatter]]
Alternative to apheleia?
** exec-path-from-shell

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (memq system-type '(darwin windows-nt))
  :init
  (setenv "SHELL" "/bin/sh")
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-envs
   '("PATH")))
#+END_SRC

** kubel                                                               :work:

#+BEGIN_SRC emacs-lisp
(use-package kubel
  :if (eq system-type 'darwin))
#+END_SRC

* Programming languages
** CSV/TSV

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :after hydra
  :mode "\\.csv\\'"
  :bind (:map csv-mode-map
	     ("C-c h" . csv-hydra/body))

  :config
 (defhydra csv-hydra (:color pink)
   "CSV HYDRA"
   ("q" nil "quit hydra" :color blue :column nil)
   ("t" csv-transpose "Transpose" :column "Test")
   ("k" csv-kill-fields "Kill fields")
   ("s" csv-sort-fields "sort by ARGth field")
   ("TAB" csv-tab-command "Next field")
   ("y" csv-yank-fields "Yank ARGth field")
   ("a" csv-align-field "Align all fields in region")
   ("A" csv-align-mode
    (concat
     (if (bound-and-true-p csv-align-mode)
	"[x]" "[ ]")
     " Toggle automatic alignment") :column "Toggles")
   ("n" next-line "Next line" :column "Test")))
#+END_SRC

To handle functions with arguments, the easiest is probably to created nested transients.
For example, calling ~k~ in the below transient results in calling a new csv-kill-fields transient which will take care of offering potential arguments?
Probably the much easier solution is to make such commands not transient which means you will exit the transient when invoking those commands.

#+BEGIN_SRC emacs-lisp
(use-package csv-mode
  :after transient
  :mode "\\.csv\\'"
  :bind (:map csv-mode-map
	     ("C-c h" . csv-transient))

  :config
  (define-transient-command csv-transient ()
    "CSV Transient Title"
    :transient-non-suffix 'transient--do-stay
    ["All"
    ["Toggles"
     ("A" csv-align-mode
      :transient t
      :description (lambda ()
		     (format "%s Align mode" (if (bound-and-true-p csv-align-mode)
						 "[x]" "[ ]"))))]
    ["Actions"
     ("t" "Transpose" csv-transpose)
     ("k" "Kill fields" csv-kill-fields :transient t)
     ("s" "Sort fields" csv-sort-fields)
     ("TAB" "Tab" csv-tab-command :transient t)
     ("y" "Yank field" csv-yank-fields :transient t)
     ("a" "Align field" csv-align-fields :transient t)
     ("n" "Next line..." next-line :transient t)]]))
#+END_SRC

** D2
#+BEGIN_SRC emacs-lisp
(use-package ob-d2
  :straight (ob-d2 :type git :host github :repo "xcapaldi/ob-d2"))
#+END_SRC

** Docker                                                              :work:

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :if (eq system-type 'darwin)
  :mode ("Dockerfile" . dockerfile-mode))
#+END_SRC

** Golang
Because typically I launch emacs via my window manager, it doesn't properly source my ~.bash_profile~.
This means I need to set the paths for Go in my config here.

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :after hydra
  :mode (("\\.go\\'" . go-mode)
	 ("\\.mod\\'" . go-dot-mod-mode))
;;  :bind (:map go-mode-map
;;	     ("C-c h" . go-hydra/body))
  :custom
  (go-play-browse-function 'browse-url-generic))
;;   :config
;;  (defhydra csv-hydra (:color pink :hint none)
;;    "
;; _q_: quit                 _y_: yank ARGth field 
;; _TAB_: Next field         _a_: align all fields in region
;; _t_: transpose            _A_: ?A? toggle automatic alignment
;; _k_: kill fields          _n_: next line
;; _s_: sort by ARGth field
;; "
;;    ("q" nil)
;;    ("t" go-coverage) ;; test coverage
;;    ("k" go-play-region)
;;    ("s" go-play-buffer)
;;    ("TAB" go-import-add)
;;    ("y" go-set-project)
;;    ("a" go-end-of-defun)
;;    ("" go-goto-imports)
;;    ("" go-guess-gopath)
;;    ("" go-plain-gopath)
;;    ("" go-reset-gopath)
;;    ("" go-fill paragraph)
;;    ("" go-goto-arguments)
;;    ("" go-goto-docstring)
;;    ("" go-mode-indent-line)
;;    ("" go-packages-go-list)
;;    ("" go-beginning-of-defun)
;;    ("" go-goto-function-name)
;;    ("" go-goto-return-values)
;;    ("" go-goto-method-receiver)
;;    ("" go-indentation-at-point)
;;    ("" go-remove-unused-imports)
;;    ("" go-goto-opening-parenthesis)))
;;    :init
;;    (setenv "GOPATH" "/home/xavier/go")
;;    (setenv "PATH" (concat (getenv "PATH") ":" (getenv "GOPATH") "/bin"))
;;    :custom
;;    (exec-path (append exec-path (list (expand-file-name "/home/xavier/go/bin/")))))
#+END_SRC

*** COMMENT godef
Not needed if using LSP.
You'll need to install godef via the go package manager: ~go get github.com/rogpeppe/godef~
This should be installed in ~$HOME/go/bin~.
It is easiest to source from emacs directly as can be seen in the above block.

*** go-dlv
GBD doesn't understand Go very well.
It is recommended to use [[https://github.com/go-delve/delve][Delve]] instead.
go-dlv provides emacs support for delve on top of GUD.

#+BEGIN_SRC emacs-lisp
(use-package go-dlv
  :straight (:host github :repo "benma/go-dlv.el"
                   :branch "master"))
#+END_SRC

If you want to run GUD on a remote host (i.e. K8 or Docker), [[https://www.gnu.org/software/emacs/manual/html_node/tramp/Remote-processes.html][check this out.]]
And this [[https://stackoverflow.com/questions/6909730/debugging-with-gdb-in-emacs-remote][Stack Overflow question]].
And most importantly, this [[https://blog.devgenius.io/debugging-go-in-kubernetes-with-delve-and-tilt-3014644378a2][guide to using Delve in Tilt]].

*** COMMENT go-flymake
This is unnecessary if using LSP.
Install this via go package manager: ~go get -u github.com/dougm/goflymake~

#+BEGIN_SRC emacs-lisp
  (use-package go-flymake
    :straight (:host github :repo "dougm/goflymake"
               :branch "master")
    :after go-mode)
#+END_SRC

*** lsp

#+BEGIN_SRC sh
go install golang.org/x/tools/gopls@latest
sudo dnf install golang-x-tools-gopls
#+END_SRC

*** ob-go
Support Go code in orgmode source blocks.

#+BEGIN_SRC emacs-lisp
(use-package ob-go
  :after org-mode)
#+END_SRC

** Javascript/Typescript
*** js                                                              :builtin:
Use the built-in js-mode as long as using emacs > v27.
This mode also handles ~.jsx~ files.

#+BEGIN_SRC emacs-lisp
(use-package js
  :straight (:type built-in)
  :mode "\\.js[x]\\'")
#+END_SRC

*** typescript-mode
There are many options for typescript (~web-mode~, ~tide~, ~js2~, ~rjsx~) but this package seems to be the most minimal.

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :mode "\\.ts[x]\\'")
#+END_SRC

*** lsp

#+BEGIN_SRC sh
sudo npm install -g typescript-language-server typescript
#+END_SRC

** Protobuf                                                            :work:

#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :if (eq system-type 'darwin)
  :mode ("\\.proto\\'"))
#+END_SRC

** Python                                                           :builtin:

#+BEGIN_SRC emacs-lisp
(use-package python
  :straight (:type built-in)
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode))
;;  :config
;;  (read-abbrev-file "~/.config/emacs/abbrevs/python.el" t)

;;  )
    ;;:mode ("\\.py\\" . python-mode)
  ;;:interpreter ("python" . python-mode)
  ;;:bind (:map python-mode-map
  ;;            ("C-c SPC" . hydra-python/body))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(define-abbrev-table 'python-mode-abbrev-table
  '(
    ("snek" "python" nil)
    ("todo" "# TODO: " nil)
    ("hw" "hello world" (7))
    ))

(defconst python-expand-list
  '(("match" "match :\ncase :\n" (7 14 16))
    )
  "Expansions for python mode")

(expand-add-abbrevs python-mode-abbrev-table python-expand-list)
#+END_SRC

*** lsp
Microsoft's pyright is quite fast although ironically it requires node to run.

#+BEGIN_SRC sh
pip install pyright
#+END_SRC

*** COMMENT Note for later

#+BEGIN_SRC emacs-lisp
(defhydra hydra-python (:color blue
			       :columns 4)
  "Coding"
  ("q" hydra-master/body "backlick"))
(define-skeleton skel-python-function
  "Insert a function template."
  "Name: "
  "def " str "(" @ - "):" \n
  "\"\"\"" @ "\"\"\"" \n
  @ _ )

(define-abbrev python-mode-abbrev-table "def" "" 'skel-python-function)
#+END_SRC

*** pyvenv

#+BEGIN_SRC emacs-lisp
(use-package pyvenv
  :after python-mode)
#+END_SRC

*** pyenv?
*** COMMENT Example abbrev and skeletons

#+BEGIN_SRC emacs-lisp
  (use-package python
    :straight (:type built-in)
    ;;:mode ("\\.py\\" . python-mode)
    ;;:interpreter ("python" . python-mode)
    :bind (:map python-mode-map
                ("C-c SPC" . hydra-python/body))
    :abbrev (:table python-mode-abbrev-table
                    ("def" "" 'skel-python-function)
                    ("hw" "hello world"))
    :abbrev ((python-mode . ("def" "" 'skel-python-function))
	         (go-mode . ("func" "" 'skel-go-function)))
    :hydra ((:color blue
                    :columns 4)

            "Coding"
            ("q" hydra-master/body "backlick"))
    :skeleton ((skel-python-function
                "Insert a function template."
                "Name: "
                "def " str "(" @ - "):" \n
                "\"\"\"" @ "\"\"\"" \n
                @ _ ))
    :config)
#+END_SRC

** SQL                                                         :builtin:work:

#+BEGIN_SRC emacs-lisp
(use-package sql
  :if (eq system-type 'darwin)
  :straight (:type built-in)
  ;;:hook (sql-interactive-mode . (toggle-truncate-lines t))
  :custom
  (sql-connection-alist
   '((local-tilt (sql-product 'postgres)
		 (sql-port 5432)
		 (sql-server "localhost")
		 (sql-user "postgres")
		 (sql-database "admin")))))
#+END_SRC

** Terraform                                                           :work:

#+BEGIN_SRC emacs-lisp
(use-package terraform-mode
  :if (eq system-type 'darwin)
  :mode ("\\.tf\\'" . terraform-mode))
#+END_SRC

** YAML

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode ("\\.yaml\\'" "\\.yml\\'"))
#+END_SRC

* Projects                                                          :builtin:

#+BEGIN_SRC emacs-lisp
(use-package project)
#+END_SRC

** COMMENT satchel
* Rectangles                                                        :builtin:
Built-in rectangle editing.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'hydra
  `(progn
     (bind-key "C-x r" #'rectangle-hydra/body)

     (defhydra rectangle-hydra (:color pink :hint none)
       "
_q_: quit  
_k_: kill  
_M-w_: copy
_d_: delete
_y_: yank
_o_: open
_N_: number lines
_c_: clear
_O_: delete whitespace
_t_: replace with string
_T_: insert string
_SPC_: ?SPC? rectangle mark mode
_r_: rectangle register
"
       ("q" nil)
       ("k" kill-rectangle)
       ("M-w" copy-rectangle-as-kill)
       ("d" delete-rectangle)
       ("y" yank-rectangle)
       ("o" open-rectangle)
       ("N" rectangle-number-lines)
       ("c" clear-rectangle)
       ("O" delete-whitespace-rectangle)
       ("t" string-rectangle)
       ("T" string-insert-rectangle)
       ("SPC" rectangle-mark-mode
	(if (bound-and-true-p rectangle-mark-mode)
	    "[x]" "[ ]"))
       ("r" rectangle-register-hydra/body))

     (defhydra rectangle-register-hydra (:color pink :hint nil)
       "
_q_: quit
_r_: copy to register
_i_: insert from register
"
       ("q" nil)
       ("r" copy-rectangle-to-register)
       ("i" insert-register))))
#+END_SRC

* Repeat
Built-in repeat functionality only in emacs 28.

#+BEGIN_SRC emacs-lisp
(use-package repeat
  :straight (:type built-in)
  :init (repeat-mode))
#+END_SRC

* RSS feed reader                                                      :home:
I have four potential use-cases for RSS feeds:

1. Follow news sources
   Perhaps not the best because an overwhelming number of articles come out each day and it is easier to pick and choose on a website.
   The only advantage of RSS here is that it can be read in plain text.
2. Follow independent blogs and projects
   This is one of the best uses for RSS.
   Rather than tracking many small writers and the updates from projects, they can be gathered here.
3. Follow journal publications (scientific literature)
   I think RSS is somewhat useless for this purpose.
   The only way this is viable is to subscribe to relevant journals, and then write some pretty extensive filtering mechanisms to try to narrow down to relevant entries.
   You can see how [[https://kitchingroup.cheme.cmu.edu/blog/category/elfeed/][Dr. Kitchin does this here]].
   However, I find Google scholar works much better and with less effort.
4. Follow YouTube channels
   I think this is another great use for RSS.
   YouTube has a way of sucking you in and is quite good at suggesting videos that *might* be interesting.
   Instead by subscribing to channels via RSS, you only watch what you've explicitely decided to follow.
   The disadvantage is that you'll never find new channels...
   To find the RSS feed for a channel you just need to look at the source of the channel page and search for ~channelid~.

** elfeed                                                              :home:
As you can see in the config below, the feed configuration is not clear at all.
We just have a URL and the tags.
There is much nicer way of managing feeds by using the [[https://github.com/remyhonig/elfeed-org][elfeed-org package]].
I decided against using it because I actually don't need that level of control and I don't want to encourage following more feeds than I can read in a day.

#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :if (eq system-type 'gnu/linux)
  :commands elfeed
  :hook (('elfeed-new-entry . (elfeed-make-tagger :feed-url "youtube\\.com"
						  :add '(video)))
	 ('elfeed-new-entry . (elfeed-make-tagger :before "2 weeks ago"
						  :remove 'unread)))
  :config
;;  (add-hook 'elfeed-new-entry-hook
;;            (elfeed-make-tagger :feed-url "youtube\\.com"
;;                                :add '(video)))
;;  (add-hook 'elfeed-new-entry-hook
;;            (elfeed-make-tagger :before "2 weeks ago"
;;                                :remove 'unread))

  (defun xcc/browse-url-mpv (url &optional single)
    ;;(async-shell-command (format "mpv %s" url)))
    (start-process "mpv" nil "mpv" url))

  :custom
  (elfeed-db-directory "~/")

  ;; use mpv to watch youtube videos
  (browse-url-browser-function
   '(("https:\\/\\/www\\.youtu\\.*be." . xcc/browse-url-mpv)
     ("." . browse-url-default-browser)))

  ;; list of feeds with autotags
  (elfeed-feeds
   '(;; news
     ("https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml" news)
     ("https://rss.nytimes.com/services/xml/rss/nyt/World.xml" news)
     ("https://rss.nytimes.com/services/xml/rss/nyt/YourMoney.xml" news finance)
     ("https://rss.nytimes.com/services/xml/rss/nyt/Business.xml" news finance)
     ("https://rss.nytimes.com/services/xml/rss/nyt/EnergyEnvironment.xml" news)
     ("https://rss.nytimes.com/services/xml/rss/nyt/Economy.xml" news finance)
     ("https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml" news)
     ("https://rss.nytimes.com/services/xml/rss/nyt/Science.xml" news)
     ;; videos
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UC21uZkfXpT8rPY-gPgMiCwA" gaming retro) ;; Civvie11
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCD6VugMZKRhSyzWEWA9W2fg" gaming) ;; SsethTzeentach
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCqJ-Xo29CKyLTjn6z2XwYAw" gaming) ;; Game Maker's Toolkit
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCKTehwyGCKF-b2wo0RKwrcg" programming) ;; Bisqwit
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCsUalyRg43M8D60mtHe6YcA" programming) ;; Honeypot
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCvjgXvBlbQiydffZU7m1_aw"  programming) ;; The Coding Train
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCaoqVlqPTH78_xjTjTOMcmQ" programming) ;; Miziziziz
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCrqM0Ym_NbK1fqeQG2VIohg" programming) ;; Tsoding Daily
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCFR-QlAx0qFHN9-QmcrpHnQ" programming) ;; Pezzza's Work
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCaiL2GDNpLYH6Wokkk1VNcg" programming) ;; mCoding
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCKCTmact-90hXpV2ns8GSsA" programming) ;; DevDuck
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCsBjURrPoezykLs9EqgamOA" programming) ;; Fireship
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UC8ENHE5xdFSwx71u3fDH5Xw" programming) ;; ThePrimeagen
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UC8uT9cgJorJPWu7ITLGo9Ww" programming retro) ;; The 8-Bit Guy
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UC5I2hjZYiW9gZPVkvzM8_Cw" retro) ;; Techmoan
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCxkMDXQ5qzYOgXPRnOBrp1w" emacs) ;; Mike Zamansky
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCDXTQ8nWmx_EhZ2v-kp7QxA" finance) ;; Ben Felix

     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCEFMBujn95FVqG_RGXCJydA" dragonboat) ;; Harrison

     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCG7AaCh_CiG6pq_rRDNw72A" music) ;; Napalm Records
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCipg-xAE_rNtL8kaG4ezFAQ") ;; Ontera
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCMb0O2CdPBNi-QqPk5T3gsQ") ;; James Hoffmann
     ("https://www.youtube.com/feeds/videos.xml?channel_id=UCsaGKqPZnGp_7N80hcHySGQ") ;; Tasting History
     ;; blogs
     ("http://blog.golang.org/feed.atom" programming golang)
     ("https://honnef.co/atom.xml" programming golang)
     ("https://research.swtch.com/feed.atom" programming golang) ;; Russ Cox

     ("https://nullprogram.com/feed/" programming)
     ("https://pvk.ca/atom.xml" programming) ;; Paul Khuong

     ("https://protesilaos.com/codelog.xml" emacs)
     ("https://feeds.feedburner.com/TheKitchinResearchGroup" emacs)
     ("https://karthinks.com/index.xml" emacs)
     ("http://pragmaticemacs.com/feed/" emacs)
     ("https://protesilaos.com/codelog.xml" emacs)

     ("http://esr.ibiblio.org/?feed=rss2")
     ("https://www.calnewport.com/blog/feed/")

     ;; other
     ("https://www.nngroup.com/feed/rss/" ux)
     ("https://suckless.org/atom.xml")
     ("https://gnucash.org/atom.php" finance)
     )))
#+END_SRC

** TODO elfeed-tube
** COMMENT newsticker                                                       :builtin:
When quitting the newsticker treeview, it saves the feed groups to file using ~newsticker-treeview-save~.
This function uses ~prin1-to-string~ to convert the group objects to string but that function uses the settings of ~print-length~ and ~print-level~ to determine when the output should be abbreviated.
There is a [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=53638][patch to fix this group issue]].
In the meantime, I will just advise the function.
I did not fix the path issues which means this will only work on Unix systems.
The full patch is necessary to work on Windows.

#+BEGIN_SRC emacs-lisp
(use-package newsticker
  :if (eq system-type 'gnu/linux)
  :straight (:type built-in)
  :after hydra
  :commands (newsticker-start newsticker-treeview newsticker-plainview)
  :bind (:map newsticker-treeview-mode-map
	      ("C-c h" . newsticker-treeview-hydra/body))
  :init
  (defun xcc/newsticker-treeview-save ()
    "Save treeview group settings."
    (interactive)
    (let ((coding-system-for-write 'utf-8)
	  (buf (find-file-noselect (concat newsticker-dir "/groups")))
	  (print-level nil)
	  (print-length nil))
      (when buf
	(with-current-buffer buf
	  (setq buffer-undo-list t)
	  (erase-buffer)
	  (insert ";; -*- coding: utf-8 -*-\n")
	  (insert (prin1-to-string newsticker-groups))
	  (save-buffer)
	  (kill-buffer)))))
  (advice-add 'newsticker-treeview-save :override #'xcc/newsticker-treeview-save)

  (defun xcc/newsticker--cache-save-feed (feed)
  "Save cache data for FEED."
  (let ((dir (file-name-as-directory
	      (expand-file-name (symbol-name (car feed))
				(newsticker--cache-dir))))
	(print-level nil)
	(print-length nil))
    (unless (file-directory-p dir)
      (make-directory dir t))
    (let ((coding-system-for-write 'utf-8))
      (with-temp-file (concat dir "/data")
        (insert ";; -*- coding: utf-8 -*-\n")
        (insert (prin1-to-string (cdr feed)))))))
  (advice-add 'newsticker--cache-save-feed :override #'xcc/newsticker--cache-save-feed)
  :custom
  (newsticker-url-list-defaults 'nil)
  (newsticker-url-list
   '(("New York Times Home Page" "https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml")
     ("New York Times World" "https://rss.nytimes.com/services/xml/rss/nyt/World.xml")
     ("New York Times Yor Money" "https://rss.nytimes.com/services/xml/rss/nyt/YourMoney.xml")
     ("New York Times Business" "https://rss.nytimes.com/services/xml/rss/nyt/Business.xml")
     ("New York Times Energy/Environment" "https://rss.nytimes.com/services/xml/rss/nyt/EnergyEnvironment.xml")
     ("New York Times Economy" "https://rss.nytimes.com/services/xml/rss/nyt/Economy.xml")
     ("New York Times Technology" "https://rss.nytimes.com/services/xml/rss/nyt/Technology.xml")
     ("New York Times Science" "https://rss.nytimes.com/services/xml/rss/nyt/Science.xml")
     ("Civvie11" "https://www.youtube.com/feeds/videos.xml?channel_id=UC21uZkfXpT8rPY-gPgMiCwA")
     ("SsethTzeentach" "https://www.youtube.com/feeds/videos.xml?channel_id=UCD6VugMZKRhSyzWEWA9W2fg")
     ("Game Maker's Toolkit" "https://www.youtube.com/feeds/videos.xml?channel_id=UCqJ-Xo29CKyLTjn6z2XwYAw")
     ("Bisqwit" "https://www.youtube.com/feeds/videos.xml?channel_id=UCKTehwyGCKF-b2wo0RKwrcg")
     ("Honeypot" "https://www.youtube.com/feeds/videos.xml?channel_id=UCsUalyRg43M8D60mtHe6YcA")
     ("The Coding Train" "https://www.youtube.com/feeds/videos.xml?channel_id=UCvjgXvBlbQiydffZU7m1_aw")
     ("javidx9" "https://www.youtube.com/feeds/videos.xml?channel_id=UC-yuWVUplUJZvieEligKBkA")
     ("Miziziziz" "https://www.youtube.com/feeds/videos.xml?channel_id=UCaoqVlqPTH78_xjTjTOMcmQ")
     ("Tsoding Daily" "https://www.youtube.com/feeds/videos.xml?channel_id=UCrqM0Ym_NbK1fqeQG2VIohg")
     ("Pezzza's Work" "https://www.youtube.com/feeds/videos.xml?channel_id=UCFR-QlAx0qFHN9-QmcrpHnQ")
     ("mCoding" "https://www.youtube.com/feeds/videos.xml?channel_id=UCaiL2GDNpLYH6Wokkk1VNcg")
     ("DevDuck" "https://www.youtube.com/feeds/videos.xml?channel_id=UCKCTmact-90hXpV2ns8GSsA")
     ("Fireship" "https://www.youtube.com/feeds/videos.xml?channel_id=UCsBjURrPoezykLs9EqgamOA")
     ("The 8-Bit Guy" "https://www.youtube.com/feeds/videos.xml?channel_id=UC8uT9cgJorJPWu7ITLGo9Ww")
     ("Techmoan" "https://www.youtube.com/feeds/videos.xml?channel_id=UC5I2hjZYiW9gZPVkvzM8_Cw")
     ("Mike Zamansky" "https://www.youtube.com/feeds/videos.xml?channel_id=UCxkMDXQ5qzYOgXPRnOBrp1w")
     ("Tasting History" "https://www.youtube.com/feeds/videos.xml?channel_id=UCsaGKqPZnGp_7N80hcHySGQ")
     ("Napalm Records" "https://www.youtube.com/feeds/videos.xml?channel_id=UCG7AaCh_CiG6pq_rRDNw72A")
     ("Ontera" "https://www.youtube.com/feeds/videos.xml?channel_id=UCipg-xAE_rNtL8kaG4ezFAQ")
     ("James Hoffmann" "https://www.youtube.com/feeds/videos.xml?channel_id=UCMb0O2CdPBNi-QqPk5T3gsQ")
     ("The Kitchin Research Group" "https://feeds.feedburner.com/TheKitchinResearchGroup")
     ("Karthinks" "https://karthinks.com/index.xml")
     ("Null Program" "https://nullprogram.com/feed/")
     ("Pragmatic Emacs" "http://pragmaticemacs.com/feed/")
     ("Protesilaos" "https://protesilaos.com/codelog.xml")
     ("Honnef" "https://honnef.co/atom.xml")
     ("Paul Khuong" "https://pvk.ca/atom.xml")
     ("Russ Cox" "https://research.swtch.com/feed.atom")
     ("Suckless" "https://suckless.org/atom.xml")
     ("GnuCash" "https://gnucash.org/atom.php")))
  :config
  (defhydra newsticker-treeview-hydra (:color amaranth :hint none)
    "
_q_: quit          _SPC_: next page      _j_: jump                    _R_: manage groups

_F_: prev feed     _p_: prev item        _P_: prev new/immortal item
_f_: next feed     _n_: next item        _N_: next new/immortal item

_g_: get news      _i_: toggle immortal  _b_: browse url item
_G_: get all news  _o_(_O_): toggle old    _v_: browse url
"
    ("q" newsticker-treeview-quit :color blue)
    ("Q" nil :color blue) ;; in case we just want to exit the hydra
    ("F" newsticker-treeview-prev-feed)
    ("f" newsticker-treeview-next-feed)
    ("g" newsticker-treeview-get-news)
    ("G" newsticker-get-all-news)
    ("SPC" newsticker-treeview-next-page)
    ("j" newsticker-treeview-jump)
    ("p" newsticker-treeview-prev-item)
    ("n" newsticker-treeview-next-item)
    ("i" newsticker-treeview-toggle-item-immortal)
    ("o" newsticker-treeview-mark-item-old)
    ("O" newsticker-treeview-mark-list-items-old)
    ("P" newsticker-treeview-prev-new-or-immortal-item)
    ("N" newsticker-treeview-next-new-or-immortal-item)
    ("b" newsticker-treeview-browse-url-item)
    ("v" newsticker-treeview-browse-url)
    ("R" newsticker-treeview-group-hydra/body :color blue))

  (defhydra newsticker-treeview-group-hydra (:color red :hint none)
    "
_q_: quit
_p_: shift group up    _F_: shift feed up
_n_: shift group down  _f_: shift feed down
_a_: add group         _m_: move feed
_d_: delete group      _s_: save groups
_r_: rename group      _u_: update
"
    ("q" newsticker-treeview-hydra/body :color blue)
    ("p" newsticker-group-shift-group-up)
    ("n" newsticker-group-shift-group-down)
    ("F" newsticker-group-shift-feed-up)
    ("f" newsticker-group-shift-feed-down)
    ("a" newsticker-group-add-group)
    ("d" newsticker-group-delete-group)
    ("m" newsticker-group-move-feed)
    ("r" newsticker-group-rename-group)
    ("s" newsticker-treeview-save)
    ("u" newsticker-treeview-update)))
#+END_SRC

* Shells
** eshell                                                      :builtin:work:

#+BEGIN_SRC emacs-lisp
(use-package eshell
  :if (eq system-type 'darwin)
  :straight (:type built-in)
  :custom
  ;; commands which should run in a dedicated terminal
  (eshell-visual-commands '("vi" "vim" "screen" "tmux" "top" "htop" "less" "more" "lynx" "links" "ncftp" "mutt" "pine" "tin" "trn" "elm"))
  ;; command options which need to run in a dedicated terminal
  (eshell-visual-options '(("git" "--help" "--paginate")))
  ;; subcommands which need to run in a dedicated terminal
  (eshell-visual-subcommands '(("git" "log" "diff" "show"))))
#+END_SRC

** eshell with smart mode                                      :builtin:home:
This appears to lag terribly as soon as you have a full page of text.


#+BEGIN_SRC emacs-lisp
(use-package eshell
  :if (eq system-type 'gnu/linux)
  :straight (:type built-in)
  :config
  (add-to-list 'eshell-modules-list 'eshell-smart)
  :custom
  ;; commands which should run in a dedicated terminal
  (eshell-visual-commands '("vi" "vim" "screen" "tmux" "top" "htop" "less" "more" "lynx" "links" "ncftp" "mutt" "pine" "tin" "trn" "elm"))
  ;; command options which need to run in a dedicated terminal
  (eshell-visual-options '(("git" "--help" "--paginate")))
  ;; subcommands which need to run in a dedicated terminal
  (eshell-visual-subcommands '(("git" "log" "diff" "show"))))

(use-package em-smart
  :if (eq system-type 'gnu/linux)
  :straight (:type built-in)
  :after eshell
  :custom
  (eshell-where-to-jump 'begin)
  (eshell-review-quick-commands t)
  (eshell-smart-space-goes-to-end nil))
#+END_SRC

** EZF
An alternative to fzf which uses emacs' built-in completions.

#+BEGIN_SRC emacs-lisp
(use-package ezf
  :straight (ezf :type git :host github :repo "xcapaldi/ezf")
  :commands ezf)
#+END_SRC

You need to ensure ezf is available on path:

#+BEGIN_SRC sh :dir /sudo::
ln -s /home/xavier/.config/emacs/straight/repos/ezf/ezf /usr/local/bin/ezf
#+END_SRC

* Search and navigation
** TODO isearch                                                     :builtin:

#+BEGIN_SRC emacs-lisp
(use-package isearch
  :straight (:type built-in)
  :after hydra
  :bind (:map isearch-mode-map
	      ("C-c h" . isearch-hydra/body))
  :config
  (defhydra isearch-hydra (:color amaranth)
    "SWIPER HYDRA"
    ("q" nil "quit hydra" :color blue :column nil)
    ("c" isearch-toggle-case-fold
     (concat
      (if (bound-and-true-p isearch-case-fold-search)
	  "[x]" "[ ]")
      " case folding"))
    ("i" isearch-toggle-invisible
     (if (string-equal isearch-invisible "open")
	 "[x]" "[ ]"))
    ("r" isearch-toggle-regexp
     (if (bound-and-true-p isearch-regexp)
	 "[x]" "[ ]"))
;;    ("w" isearch-toggle-word
;;     (if (bound-and-true-p isearch-word)
;;	 "[x]" "[ ]"))
;;    ("s" isearch-toggle-symbol
;;     (if (bound-and-true-p isearch-symbol)
;;	 "[x]" "[ ]"))
;;    ("'" isearch-toggle-char-fold
;;     (if (bound-and-true-p isearch-case-fold-search)
;;	 "[x]" "[ ]"))
    ("SPC" isearch-toggle-lax-whitespace
     (if (bound-and-true-p isearch-lax-whitespace)
	 "[x]" "[ ]"))))
#+END_SRC

** COMMENT anzu

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :after isearch
  :config (global-anzu-mode +1)
  :bind (([remap query-replace] . anzu-query-replace)
         ([remap query-replace-regexp] . anzu-query-replace-regexp)
         ([remap isearch-query-replace] . anzu-isearch-query-replace)
         ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp)))
#+END_SRC

** TODO avy

We can replace the default binding of ~M-g g~ which is ~goto-line~ with ~avy-goto-line~.
Entering a number falls back to standard ~goto-line~.

[[https://karthinks.com/software/avy-can-do-anything/][Avy can do anything by Karthinks]]

We replace the ~C-z~ default binding of suspending the frame since it is rarely useful.

#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind (("C-c s" . avy-goto-char-timer)
         ("C-z" . avy-goto-char-timer) ;; replace suspend frame
         ([remap goto-line] . avy-goto-line) ;; M-g g or M-g M-g
         :map isearch-mode-map
         ("C-c s" . avy-isearch))
  :custom
  (avy-style 'at-full)
  (avy-timeout-seconds 0.25))
#+END_SRC

* Subword

#+BEGIN_SRC emacs-lisp
(use-package subword
  :straight (:type built-in)
  :hook (prog-mode . subword-mode))
#+END_SRC

* Syntax highlighting and visual support
** dimmer

#+BEGIN_SRC emacs-lisp
(use-package dimmer
  :config
  (setq dimmer-fraction 0.3)
  (setq dimmer-adjustment-mode :foreground)
  (setq dimmer-use-colorspace :rgb)

  (dimmer-mode 1))
#+END_SRC

** focus

#+BEGIN_SRC emacs-lisp
(use-package focus
  :commands (focus-mode))
#+END_SRC

** font
For some reason the font is miniscule on Mac so I have to set the font size much larger.

#+BEGIN_SRC emacs-lisp
(if (eq system-type 'gnu/linux)
    (progn (set-face-attribute 'default nil
                               :family "JetBrains Mono"
                               :height 90
                               :weight 'medium)
           (setq line-spacing 0.2))
  (progn (set-face-attribute 'default nil
                             :family "JetBrains Mono"
                             :height 140
                             :weight 'regular)
         (setq line-spacing 0.2)))
#+END_SRC

** goggles
Holy equivalent of evil-goggles

#+BEGIN_SRC emacs-lisp
(use-package goggles
  :init (goggles-mode 1)
  :custom
  (goggles-pulse t))
#+END_SRC

** hl-todo
Highlight todo items

#+BEGIN_SRC emacs-lisp
(use-package hl-todo)
#+END_SRC

Has functionality to [[https://github.com/tarsius/hl-todo][jump between todos]] as well.

** minions
There are already a variety of tools to hide various minor modes in the mode-line.
[[https://github.com/raxod502/blackout][Blackout]] from raxod comes to mind.
These packages require you to specify for each minor mode whether or not it should be visible.
Minions takes a blanket approach of putting all minor modes into one menu.
I like this because I rarely care to see the minor modes (i.e. I more often don't want to see rather than see).
Also by having a blanket package like this, I don't need to pollute my blocks for every package.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :init
  (minions-mode 1)
  :custom
  (minions-prominent-modes '(
			     meow-beacon-mode
			     meow-insert-mode
			     meow-keypad-mode
			     meow-motion-mode
			     meow-normal-mode
                 flymake-mode)))
#+END_SRC

** modus-themes
#+BEGIN_SRC emacs-lisp
(progn (setq modus-themes-org-blocks nil)
       (load-theme 'modus-operandi t))
#+END_SRC

** prism.el
I think standard syntax highlighting is largely useless.
When looking closely, you can just read the words and not rely on colors.
When looking at the document structure, the syntax highlighting is useless.
I tried my hand at making a minimal colorscheme for vim in the past and it was quite nice but didn't really change the underlying methodology.
This package by alphapapa effectively highlights code depth.
This is useful when looking closely because errors will still have highlighting issues.
It's also very useful when looking at the whole structure to understand the depth of your code.

#+BEGIN_SRC emacs-lisp
(use-package prism
  ;; Tiltfile doesn't have any Emacs support so use prism as a syntax highlighter
  :mode ("\\Tiltfile\\'" . prism-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
:hook
  ;; lisp and C-like languages use prism-mode
  ((emacs-lisp-mode c-mode) . prism-mode)
  ;; for whitespace languages or those whose depth isn't indicated with parenthesis use prism-whitespace-mode
  ((python-mode sh-mode) . prism-whitespace-mode)
  :config
  ;; work with modus themes
  (setq prism-num-faces 16)
  (prism-set-colors
    :desaturations '(0) ; may lower the contrast ratio
    :lightens '(0)      ; same
    :colors (modus-themes-with-colors
	      (list fg-main
		    magenta
		    cyan-alt-other
		    magenta-alt-other
		    blue
		    magenta-alt
		    cyan-alt
		    red-alt-other
		    green
		    fg-main
		    cyan
		    yellow
		    blue-alt
		    red-alt
		    green-alt-other
		    fg-special-warm))))
#+END_SRC

** pulsar.el
Emacs has a built-in ~pulse.el~ which works well enough.
If you want to try it, check out [[https://karthinks.com/software/batteries-included-with-emacs/#pulse--pulse-dot-el][Karthink's blog]].
This package extends ~pulse.el~ and is a bit more minimalistic than ~beacon~ which offers similar functionality.

#+BEGIN_SRC emacs-lisp
(use-package pulsar
  :bind (("C-c h p" . pulsar-pulse-line)
         ("C-c h h" . pulsar-highlight-dwim))
  :init (pulsar-global-mode 1)
  :custom
  (pulsar-pulse t)
  (pulsar-delay 0.055)
  (pulsar-iterations 10)
  (pulsar-face 'pulsar-magenta)
  (pulsar-highlight-face 'pulsar-yellow)
  (pulsar-pulse-functions '(recenter-top-bottom
                            move-to-window-line-top-bottom
                            reposition-window
                            bookmark-jump
                            other-window
                            ace-window
                            delete-window
                            delete-other-windows
                            forward-page
                            backward-page
                            scroll-up-command
                            scroll-down-command
                            windmove-right
                            windmove-left
                            windmove-up
                            windmove-down
                            windmove-swap-states-right
                            windmove-swap-states-left
                            windmove-swap-states-up
                            windmove-swap-states-down
                            tab-new
                            tab-close
                            tab-next
                            org-next-visible-heading
                            org-previous-visible-heading
                            org-forward-heading-same-level
                            org-backward-heading-same-level
                            outline-backward-same-level
                            outline-forward-same-level
                            outline-next-visible-heading
                            outline-previous-visible-heading
                            outline-up-heading))

  (pulsar-global-mode 1))
#+END_SRC

** rainbow-delimiters

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode. rainbow-delimiters-mode))
#+END_SRC

** rainbow-mode
Replace hex color codes with the actual color.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :init (rainbow-mode 1))
#+END_SRC

** tree sitter

#+BEGIN_SRC emacs-lisp
(use-package tree-sitter
  :after treesitter-langs
  :hook (tree-sitter-after-on . tree-sitter-hl-mode)
  :init
  (global-tree-sitter-mode))
#+END_SRC

*** language support

#+BEGIN_SRC emacs-lisp
(use-package tree-sitter-langs)
#+END_SRC

** undo-hl
Highlight undo and redo actions

#+BEGIN_SRC emacs-lisp
(use-package undo-hl
  :straight (undo-hl :type git :host github :repo "casouri/undo-hl"))
#+END_SRC

** whitespace.el                                                    :builtin:
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :straight (:type built-in)
  :init (global-whitespace-mode 1)
  :custom
  (whitespace-style (quote (face trailing missing-newline-at-eof empty tab-mark)))
  (whitespace-display-mappings
   '(
     ;;(space-mark 32 [183] [46]) ; SPACE 32  , 183 MIDDLE DOT , 46 FULL STOP .
     ;;(newline-mark 10 [8595 10]) ; LINE FEED,
     (tab-mark 9 [9482 9] [92 9]) ; tab BOX DRAWINGS LIGHT QUADRUPLE DASH VERTICAL 
     ;;(tab-mark 9 [9500 9472 9472 9472]) ; tab BOX DRAWINGS LIGHT VERTICAL AND RIGHT  BOX DRAWINGS LIGHT HORIZONTAL 
     ;;(tab-mark 9 (vconcat [9500] (make-vector tab-width 9472)))
     )))
#+END_SRC

* Transient
Hydra and Transient satisfy similar needs.
Hydra is easier to work with but less powerful.
Transient can be used to create interface to cli commands with modifying flags.

#+BEGIN_SRC emacs-lisp
(use-package transient)
#+END_SRC

** COMMENT Appending new commands for transient
#+BEGIN_SRC emacs-lisp
(use-package linum
  :straight (:type built-in)
  :hook
  :config
  (transient-define-suffix line-suffix ()
      "This is a test suffix"
      :description "line stuff"
      (interactive)
      (message "heyo"))
  (transient-append-suffix 'csv-transient '(0) ;; after the first group
    ["My group"
     ("x" line-suffix)
     ])
  )
#+END_SRC

* Undo
Emacs undo system is both very powerful and very hard to use.
It is fundamentally a single stack of operations but the complexity comes from the fact that undo operations are pushed onto the stack as well and redo is undoing of the undo.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'hydra
  '(defhydra undo-hydra (:color pink :hint nil)
     "
_q_: quit
_z_: undo
_Z_: undo only
"
     ("q" nil)
     ("z" undo)
     ("Z" undo-only)))
#+END_SRC

** vundo
#+BEGIN_SRC emacs-lisp
(use-package vundo
  :straight (vundo :type git :host github :repo "casouri/vundo")
  :commands (vundo)
  :bind ("C-c u" . vundo))
#+END_SRC

* Version control
** magit

#+BEGIN_SRC emacs-lisp
(use-package magit)
#+END_SRC

** magit-todos
Highlight todos in magit interface.

#+BEGIN_SRC emacs-lisp
(use-package magit-todos
  :hook magit-mode)
#+END_SRC

** TODO forge
Work with git forges with Github and Gitlab

* Window navigation
** ace-window
We can replace the default binding of ~C-x o~ which is ~other-window~ with ~ace-window~.
If there are only two windows, it falls back to ~other-window~.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind ([remap other-window] . ace-window)) ;; C-x o
#+END_SRC

* wgrep
#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :straight (wgrep :type git :host github :repo "mhayashi1120/Emacs-wgrep"))
#+END_SRC
