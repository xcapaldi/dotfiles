#+TITLE: Emacs Configuration
#+AUTHOR: Xavier Capaldi
#+PROPERTY: header-args :results silent :exports code

This is my literate emacs configuration.
It currently uses the native ~package.el~ but a future version may use [[https://github.com/radian-software/straight.el][straight.el]] or [[https://github.com/progfolio/elpaca][elpaca]].
Otherwise it tries to use a limited set of packages that mostly augment the natural emacs workflow.

* COMMENT comments in literate configuration
One really nice benefit of the literate configurations is that commented blocks are not rendered in Github.
This allows us to store configurations/packages that are still being tested without making them "active".

* early init file
The [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Early-Init-File.html][early init file]] is loaded before the package system or GUI is initialized.
We would also use it to disable ~package.el~ if we used an alternative package manager.
Rather than deal with any complications, I'll just use ~package.el~ for now.

We would also use it to disable graphical features before start but instead since we are manually running this config, I put at the head of =init.el=.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)
(tool-bar-mode -1)
#+END_SRC

* init file
The actual init file will only configure =package.el= and then tangle this literate configuration and load it.

** package.el
#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/"))

(package-initialize)
#+END_SRC

** load literate configuration
#+BEGIN_SRC emacs-lisp :tangle init.el
(org-babel-load-file "~/.config/emacs/config.org")
#+END_SRC

* package management
** [[https://github.com/jwiegley/use-package][use-package]]                                                     :jwiegley:
=use-package= is a package configuration tool that allows us to manage each package in a single isolated block.
It has finally been incorporated into Emacs proper.

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
#+END_SRC

** [[https://github.com/slotThe/vc-use-package][vc-use-package]]                                                   :slotThe:
=package.el= supports installing packages from a version-controlled source.
Integration of this feature with =use-package= was merged into Emacs proper but missed the Emacs 29 release deadline.
This package adds =use-package= support.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'vc-use-package)
  (package-vc-install "https://github.com/slotThe/vc-use-package"))
#+END_SRC

* [[https://github.com/emacscollective/no-littering][no-littering]]
Emacs has a tendency to clutter the config directory.
This package tries to automagically keep things clean.
In addition, this package can handle storing backups and autosaves in a centralized directory.
It should be initialized as early as possible in the configuration.

#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :ensure t
  :config
  (no-littering-theme-backups)) ; store backups and autosaves in centralized directories
#+END_SRC

* general emacs settings
#+BEGIN_SRC emacs-lisp :noweb yes
(use-package emacs
  :init
  <<MINIBUFFER>>
  :config
  <<SET_DEFAULTS>>
  <<SET_GLOBAL_MODES>>
  <<LOAD_THEME>>
  (when (equal system-type 'darwin)
    <<REBIND_MAC_KEYS>>
    <<MAC_FONTS>>))
#+END_SRC

** set defaults
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref SET_DEFAULTS
(setq-default
 coding-system-for-read 'utf-8                ; Use UTF-8 by default
 coding-system-for-write 'utf-8
 cursor-in-non-selected-windows t             ; Don't hide the cursor in inactive windows
 help-window-select t                         ; Focus new help windows when opened
 indent-tabs-mode nil                         ; Prefer spaces over tabs
 indicate-empty-lines t                       ; Display bitmap in left fringe on empty lines
 inhibit-startup-screen t                     ; Remove default start screen
 ring-bell-function 1                         ; Use a visual bell
 select-enable-clipboard t                    ; Merge emacs and system clipboard
 tab-always-indent 'complete                  ; Use tab as a completion instead of C-M-i
 tab-width 4                                  ; Set width for tabs
 view-read-only t                             ; Always open read-only buffers in view-mode
 visible-bell t                               ; Use a visual bell
 vc-follow-symlinks t)                        ; Don't ask for confirmation following symlinked files
 #+END_SRC

** set global modes
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref SET_GLOBAL_MODES
(global-visual-line-mode 0)            ; Don't always wrap lines instead of extending past view
(global-hl-line-mode 1)                ; Highlight current line
(display-fill-column-indicator-mode 0) ; add indicator for the fill line
(column-number-mode 1)                 ; Show the column number
(fset 'yes-or-no-p 'y-or-n-p)          ; Replace yes/no prompts with y/n
(tool-bar-mode 1)                      ; Hide the toolbar
(menu-bar-mode 1)                      ; Hide the menubar
(tooltip-mode 0)                       ; Remove mouse hover tooltips
(scroll-bar-mode 1)                    ; Hide the scrollbar
(blink-cursor-mode 0)                  ; Don't blink the cursor
(show-paren-mode 1)                    ; Show matching parens
(global-auto-revert-mode 1)            ; If file changes on disk, update the buffer automatically
(pixel-scroll-precision-mode 1)        ; Smooth scrolling
(context-menu-mode 0)                  ; Don't replace standard mouse-3 actions with context menu
#+END_SRC

** minibuffer
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref MINIBUFFER
;; Do not allow the cursor in the minibuffer prompt
(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
(setq enable-recursive-minibuffers t)
#+END_SRC

** theme
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref LOAD_THEME
(load-theme 'modus-operandi t)
#+END_SRC

** fonts
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref MAC_FONTS
(when (member "Unifont" (font-family-list))
      (set-frame-font "Unifont-15:regular" nil t)
      (add-to-list 'initial-frame-alist '(font . "Unifont-15:regular"))
      (add-to-list 'default-frame-alist '(font . "Unifont-15:regular")))
(set-fontset-font t 'symbol (font-spec :family "Apple Symbols") nil 'prepend)
(set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend)
(setq-default line-spacing 0.1)
#+END_SRC

** remap keys on Macos
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref REBIND_MAC_KEYS
(setq mac-command-modifier 'meta)
(setq mac-option-modifier 'super)
#+END_SRC

* COMMENT ace-window
* [[https://github.com/emacsorphanage/anzu][anzu]]
The principle benefit of this package is to display the number of matching results in an =isearch= query.
That only is nice improvement in the user experience.
In addition this package improves the UX when doing a query replace (=M-%= in =isearch=).

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :bind (([remap isearch-query-replace] . anzu-isearch-query-replace)
         ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp))
  :init (global-anzu-mode 1)
  :custom ((anzu-deactivate-region t) ; deactivate region when anzu overlay starts for constrast
           (anzu-search-threshold 1000)
           (anzu-replace-threshold 50)
           (anzu-replace-to-string-separator " => ")))
#+END_SRC

* COMMENT [[https://github.com/radian-software/apheleia][apheleia]]
* [[https://github.com/tabfugnic/asdf.el][asdf]]
asdf is a [[https://asdf-vm.com/][version manager]] used at my work to control the versions of some developer tools.
The corresponding emacs package does all necessary environment setup so tools installed by asdf are accessible in emacs.

#+BEGIN_SRC emacs-lisp
(use-package asdf
  :vc (:fetcher github :repo tabfugnic/asdf.el)
  :if (eq system-type 'darwin)
  :config (asdf-enable))
#+END_SRC

* [[https://github.com/abo-abo/avy][avy]]

#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind (("C-c s" . avy-goto-char-timer)
         ("C-z" . avy-goto-char-timer) ;; replace suspend frame
         ([remap goto-line] . avy-goto-line) ;; M-g g or M-g M-g
         :map isearch-mode-map
         ("C-c s" . avy-isearch))
  :custom
  (avy-style 'at-full)
  (avy-timeout-seconds 0.25)
  (avy-case-fold-search nil)
  (avy-background nil))
#+END_SRC

* [[https://github.com/tuh8888/chezmoi.el][chezmoi]]
chezmoi is a [[https://www.chezmoi.io/][dotfiles manager]] that I use to manage my configurations (including this one).
This package exposes some chezmoi commands to emacs.

#+BEGIN_SRC emacs-lisp
(use-package chezmoi
  :ensure t)
#+END_SRC

* [[https://github.com/minad/consult][consult]]
#+BEGIN_SRC emacs-lisp
(use-package consult
  :ensure t
  :bind (([remap switch-to-buffer] . consult-buffer) ;; C-x b
         ([remap yank-pop] . consult-yank-pop) ;; M-y
         :map isearch-mode-map
              ("C-c l" . consult-line)))
#+END_SRC

* COMMENT consult-eglot
* [[https://github.com/zerolfx/copilot.el][copilot]]
This package integrate Github's [[https://github.com/features/copilot][Copilot]] with emacs.
The license to Copilot is provided through my work.

#+BEGIN_SRC emacs-lisp
(use-package copilot
  :vc (:fetcher github :repo zerolfx/copilot.el)
  :if (eq system-type 'darwin)
  :hook (prog-mode . copilot-mode)
  :config
  (transient-define-prefix copilot-prefix ()
    "Prefix that allow control of copilot suggestions"
    [("<return>" "accept completion" copilot-accept-completion)
     ("n" "next completion" copilot-next-completion :transient t)
     ("p" "prev completion" copilot-previous-completion :transient t)
     ("<tab>" "accept completion by line" copilot-accept-completion-by-line :transient t)
     ("<SPC>" "accept completion by word" copilot-accept-completion-by-word :transient t)
     ("<backspace>" "clear overlay" copilot-clear-overlay)])
  :bind (:map copilot-mode-map
              ("S-<tab>" . copilot-accept-completion)
              ("S-<SPC>" . copilot-accept-completion-by-word)
              ("C-c c" . copilot-prefix)))
#+END_SRC

* [[https://github.com/minad/corfu][corfu]]
This package provides a completion popup window.
There is a way to do completions using =consult= in the minibuffer but if you use that solution you cannot update the completion with further input.

#+BEGIN_SRC emacs-lisp
(use-package corfu
  :ensure t
  :config (global-corfu-mode))
#+END_SRC

* COMMENT denote
* COMMENT dimmer
* dired
Emac's native file explorer/manager.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :custom ((dired-listing-switches "-alh"))
  :config (put 'dired-find-alternate-file 'disabled nil))
#+END_SRC

* [[https://github.com/jacktasia/dumb-jump][dumb-jump]]
This package uses =grep=, =The Silver Searcher= or =ripgrep= along with some baked language heuristics to implement a fast go-to-definiton command.
LSP should usually handle this functionality but =dumb-jump= is a solid fallback that just works without configuration.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :after xref
  :custom (dumb-jump-force-searcher 'rg)
  :config (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+END_SRC

* [[https://github.com/editorconfig/editorconfig-emacs][editorconfig]]
This is an [[https://editorconfig.org/][EditorConfig]] plugin for Emacs.
While ~editorconfig-mode~ is enabled, most EditorConfig settings in projects will be respected.

#+BEGIN_SRC emacs-lisp
(use-package editorconfig
  :ensure t
  :config (editorconfig-mode 1))
#+END_SRC

* [[https://github.com/joaotavora/eglot][eglot]]
This is the built-in [[https://microsoft.github.io/language-server-protocol/][language server protocol (LSP)]] in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package eglot
  :ensure nil
  :after (project flymake xref)
  :commands eglot)
#+END_SRC

* COMMENT elfeed
* COMMENT [[https://github.com/oantolin/embark][embark]]
#+BEGIN_SRC emacs-lisp
(use-package embark
  :ensure t)
#+END_SRC

* COMMENT embark-consult
#+BEGIN_SRC emacs-lisp
(use-package embark-consult
  :ensure t)
#+END_SRC
* COMMENT eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :ensure nil
  :config
  (if (eq system-type 'gnu/linux)
      (add-to-list 'eshell-modules-list 'eshell-smart))
  :custom
  ;; commands which should run in a dedicated terminal
  (eshell-visual-commands '("vi" "vim" "screen" "tmux" "top" "htop" "less" "more" "lynx" "links" "ncftp" "mutt" "pine" "tin" "trn" "elm"))
  ;; command options which need to run in a dedicated terminal
  (eshell-visual-options '(("git" "--help" "--paginate")))
  ;; subcommands which need to run in a dedicated terminal
  (eshell-visual-subcommands '(("git" "log" "diff" "show"))))

(use-package em-smart
  :ensure nil
  :if (eq system-type 'gnu/linux)
  :after eshell
  :custom
  (eshell-where-to-jump 'begin)
  (eshell-review-quick-commands t)
  (eshell-smart-space-goes-to-end nil))
#+END_SRC

* [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]
Emacs on MacOS cannot access path properly.
This package allows Emacs to access the same environment variables as in the shell.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :if (memq window-system '(mac ns x))
  :config (exec-path-from-shell-initialize))
#+END_SRC

* COMMENT ezf
* COMMENT focus
* COMMENT [[https://github.com/benma/go-dlv.el][go-dlv]]
GBD doesn’t understand Go very well.
It is recommended to use [[https://github.com/go-delve/delve][Delve]] instead.
=go-dlv= provides emacs support for delve on top of GUD.

#+BEGIN_SRC emacs-lisp
(use-package go-dlv
  :vc (:fetcher github :repo benma/go-dlv.el))
#+END_SRC

* [[https://github.com/dominikh/go-mode.el][go-mode]]
This package provides standard language support for the Go programming language.
In addition to syntax highlighting and basic semantic motions, it provides integrations with several Go tools like =gofmt= and [[https://go.dev/play/][Go Playground]].

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t
  :mode (("\\.go\\'" . go-mode)
         ("\\.mod\\'" . go-dot-mod-mode)))
#+END_SRC

* ibuffer
=ibuffer= is nicer than =buffer-menu=.

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :ensure nil
  :bind ([remap list-buffers] . ibuffer)) ;; C-x C-b
#+END_SRC

* COMMENT icomplete

#+BEGIN_SRC emacs-lisp
(use-package icomplete
  :ensure nil
  :init (icomplete-mode)
  :custom (icomplete-prospects-height 1))
#+END_SRC

* js
The built in javascript mode.

#+BEGIN_SRC emacs-lisp
(use-package js
  :ensure nil
  :mode "\\.js[x]\\'")
#+END_SRC

* display-line-numbers
#+BEGIN_SRC emacs-lisp
(use-package display-line-numbers
  :ensure nil
  :hook (prog-mode . display-line-numbers-mode))
#+END_SRC

* COMMENT [[https://magit.vc/][magit]]
This package is a comprehensive [[https://git-scm.com/][git]] porcelain in Emacs.
Emacs has =vc-mode= which is built-in but magit is widely regarded as one of the best git interfaces.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t)
#+END_SRC

* COMMENT [[https://github.com/alphapapa/magit-todos][magit-todos]]
#+BEGIN_SRC emacs-lisp
(use-package magit-todos
  :ensure t
  :hook magit-mode)
#+END_SRC

* [[https://github.com/minad/marginalia][marginalia]]
Add helpful marginalia to minibuffer completions

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :ensure t
  :bind (:map minibuffer-local-map
              ("M-A" . marginalia-cycle))
  :config (marginalia-mode 1))
#+END_SRC

* [[https://jblevins.org/projects/markdown-mode/][markdown-mode]]
Emacs doesn't have a native markdown mode and I use it frequently in repository READMEs.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode ("README\\.md\\'" . gfm-mode))
#+END_SRC

* [[https://github.com/tarsius/minions][minions]]
There are already a variety of tools to hide various minor modes in the mode-line.
=Blackout= from raxod comes to mind.
These packages require you to specify for each minor mode whether or not it should be visible.
Minions takes a blanket approach of putting all minor modes into one menu.
I like this because I rarely care to see the minor modes (i.e. I more often don’t want to see rather than see).
Also by having a blanket package like this, I don’t need to pollute my blocks for every package.

#+BEGIN_SRC emacs-lisp
(use-package minions
  :ensure t
  :config (minions-mode 1)
  :custom (minions-prominent-modes '(flymake-mode)))
#+END_SRC

* [[https://github.com/pope/ob-go][ob-go]]
Add support for Go to org mode code blocks.

#+BEGIN_SRC emacs-lisp
(use-package ob-go
  :ensure t
  :after org-mode)
#+END_SRC

* [[https://github.com/oantolin/orderless][orderless]]
This package adds an advanced completions style to Emacs.
The style is space-separated and each separated block can match using several different completion patterns.
It sounds complex but is actually very intuitive to use compared to most of the built-in completions.

#+BEGIN_SRC emacs-lisp
(use-package orderless
  :ensure t
  :init
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC

* org
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :config
  ;; Org-babel supported languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (python . t)))
  :custom
  (org-adapt-indentation nil)
  (org-edit-src-content-indentation 0))
#+END_SRC

* COMMENT printing
* [[https://github.com/alphapapa/prism.el][prism.el]]

#+BEGIN_SRC emacs-lisp
(use-package prism
  :ensure t
  :mode (("\\.proto\\'" . prism-mode)
         ("^Tiltfile\\'" . prism-whitespace-mode)))
#+END_SRC

* [[https://github.com/protocolbuffers/protobuf/blob/main/editors/protobuf-mode.el][protobuf-mode]]
[[https://protobuf.dev/][Protocol Buffers]] are used to serialize structured data.
We use them in my work and this package adds support for the protobuf syntax.

#+BEGIN_SRC emacs-lisp
(use-package protobuf-mode
  :ensure t
  :if (eq system-type 'darwin)
  :mode ("\\.proto\\'"))
#+END_SRC

* [[https://protesilaos.com/emacs/pulsar][pulsar]]
Emacs has a built-in pulse.el which works well enough.
If you want to try it, check out Karthink’s blog.
This package extends pulse.el and is a bit more minimalistic than beacon which offers similar functionality.

#+BEGIN_SRC emacs-lisp
(use-package pulsar
  :ensure t
  :bind (("C-c h p" . pulsar-pulse-line)
         ("C-c h h" . pulsar-highlight-dwim))
  :commands (recenter-top-bottom
             move-to-window-line-top-bottom
             reposition-window
             bookmark-jump
             other-window
             ace-window
             delete-window
             delete-other-windows
             forward-page
             backward-page
             scroll-up-command
             scroll-down-command
             windmove-right
             windmove-left
             windmove-up
             windmove-down
             windmove-swap-states-right
             windmove-swap-states-left
             windmove-swap-states-up
             windmove-swap-states-down
             tab-new
             tab-close
             tab-next
             org-next-visible-heading
             org-previous-visible-heading
             org-forward-heading-same-level
             org-backward-heading-same-level
             outline-backward-same-level
             outline-forward-same-level
             outline-next-visible-heading
             outline-previous-visible-heading
             outline-up-heading)
  :config (pulsar-global-mode 1)
  :custom
  (pulsar-pulse t)
  (pulsar-delay 0.055)
  (pulsar-iterations 10)
  (pulsar-face 'pulsar-magenta)
  (pulsar-highlight-face 'pulsar-yellow)
  (pulsar-pulse-functions '(recenter-top-bottom
                            move-to-window-line-top-bottom
                            reposition-window
                            bookmark-jump
                            other-window
                            ace-window
                            delete-window
                            delete-other-windows
                            forward-page
                            backward-page
                            scroll-up-command
                            scroll-down-command
                            windmove-right
                            windmove-left
                            windmove-up
                            windmove-down
                            windmove-swap-states-right
                            windmove-swap-states-left
                            windmove-swap-states-up
                            windmove-swap-states-down
                            tab-new
                            tab-close
                            tab-next
                            org-next-visible-heading
                            org-previous-visible-heading
                            org-forward-heading-same-level
                            org-backward-heading-same-level
                            outline-backward-same-level
                            outline-forward-same-level
                            outline-next-visible-heading
                            outline-previous-visible-heading
                            outline-up-heading)))
#+END_SRC

* COMMENT puni
* COMMENT [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]]
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode. rainbow-delimiters-mode))
#+END_SRC

* COMMENT rainbow-mode
* shell
This is just a dumb emacs interface to the system shell.
It is non-interactive but retains emacs keybindings which is quite nice.
For an interactive terminal, you'll need to use =ansi-term=.

#+BEGIN_SRC emacs-lisp
(use-package shell
  :ensure nil
  :init (setq comint-process-echoes t) ; remove zsh echoing
  :config
  (defun xcc/shell-cur-dir ()
    (interactive)
    (shell (concat "*shell" default-directory "*")))
  (transient-define-prefix spawn-shell-prefix ()
    "Prefix that allows spawning shells"
    [("<return>" "current directory" xcc/shell-cur-dir)])
  :bind ("C-c s" . spawn-shell-prefix))
#+END_SRC

* subword
#+BEGIN_SRC emacs-lisp
(use-package subword
  :ensure nil
  :hook (prog-mode . subword-mode))
#+END_SRC

* [[https://github.com/hcl-emacs/terraform-mode][terraform-mode]]
This package adds support for [[https://www.terraform.io/][Terraform]] configuration files which we use at my work.

#+BEGIN_SRC emacs-lisp
(use-package terraform-mode
  :ensure t
  :if (eq system-type 'darwin)
  :mode ("\\.tf\\'" . terraform-mode))
#+END_SRC

* [[https://github.com/emacs-typescript/typescript.el][typescript-mode]]
This package add support for the Typescript programming language to Emacs.

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode
  :ensure t
  :mode "\\.ts[x]\\'")
#+END_SRC

* COMMENT undo-hl
* [[https://github.com/minad/vertico][vertico]]
An improved vertical completion UI for Emacs.
This synergizes nicely with marginalia and orderless.

#+BEGIN_SRC emacs-lisp
(use-package vertico
  :ensure t
  :config
  (vertico-mode 1))

(use-package vertico-multiform
  :after vertico
  :ensure nil
  :init (vertico-multiform-mode 1)
  :custom
  (vertico-multiform-categories
   '((file reverse )
     (consult-grep buffer)
     (consult-location buffer)
     (imenu buffer)
     (t reverse)
     ))
  (vertico-multiform-commands
   '(("flyspell-correct-*" reverse)
     (org-refile grid reverse indexed)
     (consult-yank-pop buffer)
     (consult-flymake buffer)
     (consult-lsp-diagnostics)
     )))

(use-package vertico-directory
  :after vertico
  :ensure nil
  ;; More convenient directory navigation commands
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  ;; Tidy shadowed file names
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

(use-package vertico-mouse
  :after vertico
  :ensure nil
  :init (vertico-mouse-mode 1))
#+END_SRC

* [[https://github.com/casouri/vundo][vundo]]
Emacs undo system is really hard to follow.
This package adds a undo tree visualization.

#+BEGIN_SRC emacs-lisp
(use-package vundo
  :ensure t
  :commands (vundo)
  :bind ("C-c u" . vundo))
#+END_SRC

* COMMENT [[https://github.com/justbur/emacs-which-key][which-key]]
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :custom
  ;; Allow C-h to trigger which-key before it is done automatically
  (which-key-show-early-on-C-h t)
  ;; Don't show normally but refresh quickly when triggered
  (which-key-idle-delay 10000)
  (which-key-idle-secondary-delay 0.05)
  :init (which-key-mode))
#+END_SRC

* whitespace
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :ensure nil
  :init (global-whitespace-mode 1)
  :custom
  (whitespace-style (quote (face trailing missing-newline-at-eof empty tab-mark)))
  (whitespace-display-mappings
   '(
     ;;(space-mark 32 [183] [46]) ; SPACE 32 「 」, 183 MIDDLE DOT 「·」, 46 FULL STOP 「.」
     ;;(newline-mark 10 [8595 10]) ; LINE FEED,
     (tab-mark 9 [9482 9] [92 9]) ; tab BOX DRAWINGS LIGHT QUADRUPLE DASH VERTICAL 「┊」
     ;;(tab-mark 9 [9500 9472 9472 9472]) ; tab BOX DRAWINGS LIGHT VERTICAL AND RIGHT 「├」 BOX DRAWINGS LIGHT HORIZONTAL 「─」
     ;;(tab-mark 9 (vconcat [9500] (make-vector tab-width 9472)))
     )))
#+END_SRC

* [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]]
This package allows me to edit =grep= buffers in the same way we can edit files and directories with =wdired=.

#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :vc (:fetcher github :repo mhayashi1120/Emacs-wgrep))
#+END_SRC

* COMMENT yaml-mode
